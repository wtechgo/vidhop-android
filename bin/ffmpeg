#!/bin/bash
# TODO: https://github.com/CrypticSignal/better-ffmpeg-progress

# Video.
to-x264() {
  [ -z "$1" ] &&
    echo "Usage: convert264 <SRC_FILE.EXT> [<DEST_FILE.EXT>]" &&
    echo " Info: converts the source file to x264 in the same location and appends '_264' if the destination filename was identical" && return

  src="$(realpath "$1")"
  [ ! -f "$src" ] && echo "file not found '$src', abort" && return
  dest="$(strip_extension "$src").mp4"                         # converts into the same location
  [ -f "$dest" ] && dest="$(strip_extension "$dest")_x264.mp4" # append _264 if the destination is also mp4

  ffmpeg -i "$src" -c:v libx264 -profile:v high -preset slow -f mp4 -tune film -crf 18 "$dest"
  echo "file conversion to x264 completed"
  ## instructions from https://lbry.com/faq/video-publishing-guide
  #ffmpeg -i input.avi -c:v libx264 -crf 21 -preset faster -pix_fmt yuv420p -maxrate 5000K -bufsize 5000K -vf 'scale=if(gte(iw\,ih)\,min(1920\,iw)\,-2):if(lt(iw\,ih)\,min(1920\,ih)\,-2)' -movflags +faststart -c:a aac -b:a 160k output.mp4
}

to-x265() {
  [ -z "$1" ] &&
    echo "Usage: convert264 <SRC_FILE.EXT> [<DEST_FILE.EXT>]" &&
    echo " Info: converts the source file to x265 in the same location and appends '_265' if the destination filename was identical" && return

  src="$(realpath "$1")"
  [ ! -f "$src" ] && echo "file not found '$src', abort" && return
  dest="$(strip_extension "$src").mp4"                         # converts into the same location
  [ -f "$dest" ] && dest="$(strip_extension "$dest")_x265.mp4" # append _265 if the destination is also mp4

  ffmpeg -i "$src" -c:v libx265 -preset ultrafast -crf 23 -vtag hvc1 "$dest"
  echo "file conversion to x265 completed"
}

to-720p() {
  input_file="$1"
  output_file="$(strip_extension "$input_file")_720p.$(get_extension "$input_file")"
  ffmpeg -i "$input_file" -vf scale=-1280:720 -c:a copy "$output_file"
  echo "file conversion to 720p done"
  echo "result file is at '$output_file'"
}

to-1080p() {
  input_file="$1"
  output_file="$(strip_extension "$input_file")_1080p.$(get_extension "$input_file")"
  ffmpeg -i "$input_file" -vf scale=-1920:1080 -c:a copy "$output_file"
  echo "file conversion to 1080p done"
  echo "result file is at '$output_file'"
}

cutvideo() {
  [ -z "$1" ] || [ -z "$2" ] && cat <<EOF && return
Usage: cutvideo <INPUT_FILE> <START_TIME> [<END_TIME>]

time input formats:
    formats to be used for <START_TIME> and <END_TIME>
    h=hours, m=minutes, s=seconds, m=milliseconds

    hh:mm:ss        Example: 01:30:52
    sss             Example: 120

    hh:mm:ss.mmm    Example: 01:30:52.123
    sss.mmm         Example: 120.123

The input file remains untouched.
A new file will be created with filename <TITLE>.cut.ext in the directory of the input file.
Ext is the extension of the input file e.g. mp4, mkv...

If cutvideo fails, converting the input video from mkv to mp4 may help.
One way to do this is with OBS > File > Remux.
EOF

  unset input_file start_time end_time output_file
  input_file="$1"
  start_time="$2"
  end_time="$3"
  [ -z "$3" ] && end_time="$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \
    -sexagesimal "$input_file" | sed 's/\..*//g')"
  output_file="$(prefix_extension "$input_file" cut)"

  ffmpeg -i "$input_file" -ss "$start_time" -to "$end_time" -c copy "$output_file"
  echo -e "cut video complete, result at:\n\"$output_file\""
  cd "$(dirname "$input_file")"

  echo -n "replace original with cut version? N/y: " && read -r answer
  answer=$(echo "$answer" | tr '[:upper:]' '[:lower:]')
  [ -z "$answer" ] || [ "$answer" = "n" ] && return
  [ "$answer" = "y" ] && mv "$output_file" "$input_file"
}

mergevideos() {
  [ $# -lt 3 ] &&
    echo "Usage: mergevideos <VIDEO_FILE_1> <VIDEO_FILE_2> <OUTPUT_FILE>" &&
    echo " Info: files must have the same encoding or the second video will be black" && return
  if [ -f "$1" ]; then file1="$1"; else echo "not a file '$1'" && return; fi
  if [ -f "$2" ]; then file2="$2"; else echo "not a file '$2'" && return; fi
  output_file="$3"

  text_file=concat_demuxer.txt
  touch "$text_file"
  echo "file '$file1'" >>"$text_file"
  echo "file '$file2'" >>"$text_file"

  ffmpeg -f concat -safe 0 -i "$text_file" -c copy "$output_file"
  rm "$text_file"
  echo "merge video at '$output_file'"
}

embed-thumbnail-into-video() { # not tested
  [ $# -lt 2 ] && echo "Usage: embed-thumbnail-into-video <THUMBNAIL_FILE> <VIDEO_FILE>" && return
  thumb_file="$1" && [ ! -f "$thumb_file" ] && echo "not a file: '$thumb_file'" && return
  input_file="$2" && [ ! -f "$input_file" ] && echo "not a file: '$input_file'" && return
  output_file="$(prefix_extension "$input_file" thumb)"
  ext_thumb="$(get_extension "$thumb_file")"
  echo -e " input: $input_file\n output: $output_file\n thumb: $thumb_file\n ext_thumb: $ext_thumb"

  if [[ "$input_file" == *.mkv ]] || [[ "$input_file" == *.MKV ]]; then
    echo "using ffmpeg for MKV..."
    if [ "$(command -v magick)" ]; then # convert image to jpg
      thumb_temp_file="$(strip_extension "$thumb_file").temp.jpg"
      magick "$thumb_file" "$thumb_temp_file" # keeps original image
      thumb_file="$thumb_temp_file"
    fi
    ffmpeg -i "$input_file" \
      -attach "$thumb_file" \
      -metadata:s:t:0 mimetype=image/jpeg \
      -c copy "$output_file"
    [ -f "$thumb_temp_file" ] && rm "$thumb_temp_file"
  else
    echo "using ffmpeg for MP4, MOV,..."
    ffmpeg -i "$input_file" -i "$thumb_file" -acodec copy -vcodec copy -map 0 -map 1:0 "$output_file"
    #    ffmpeg -i "$input_file" -i "$thumb_file" -map 0 -map 1 -c copy -c:v:1 "$ext_thumb" -disposition:v:1 attached_pic "$output_file"
    #    ffmpeg -i video.mp4 -i image.png -map 0 -map 1 -c copy -c:v:1 png -disposition:v:1 attached_pic out.mp4
    #    ffmpeg -i "$input_file" -i "$thumb_file" -map 1 -map 0 -c copy -disposition:0 attached_pic "$output_file"
    #    ffmpeg -i "$input_file" \
    #      -i "$thumb_file" \
    #      -map 1 \
    #      -map 0:V \
    #      -c copy \
    #      -disposition:0 attached_pic "$output_file"
  fi
}

mp3+thumbnail2video() {
  audio_file="$(realpath "$1")"
  image_file="$(realpath "$2")"
  output_file="$(strip_extension "$audio_file").mp4"
  [ -z "$output_file" ] && output_file="$3"
  [ -z "$audio_file" ] || [ -z "$image_file" ] || [ -z "$output_file" ] &&
    echo "Usage: mp3+thumbnail2video <AUDIO_FILE> <IMAGE_FILE> [<OUTPUT_FILE>]" && return
  ffmpeg -loop 1 -r 1 -i "$image_file" -i "$audio_file" -c:a copy -shortest -c:v libx264 "$output_file"
}

convert-webp2jpg-dir() {
  [ -h "$1" ] && echo "Usage: convert-webp2jpg-dir <DIRECTORY>" && return
  dir="$(realpath "$1")" 2>/dev/null
  [ -z "$1" ] && dir="$(realpath "$PWD")"
  [ ! -d "$dir" ] && echo "not a directory '$dir'" && return

  while read -r file; do
    jpgFile="$(strip_extension "$file").jpg"
    magick "$file" "$jpgFile"
    [ -f "$jpgFile" ] && rm "$file"
  done < <(find "$dir" -iname "*.webp" -o -iname "*.WEBP")
}

replaceaudio() {
  [ -z "$1" ] || [ -z "$2" ] && echo "Usage: replaceaudio <VIDEO_FILE> <AUDIO_FILE>" && return
  video_file="$1"
  audio_file="$2"
  backup_file="$(prefix_extension "$video_file" backup)"
  cp "$video_file" "$backup_file"
  ffmpeg -i "$backup_file" -i "$audio_file" -c copy -map 0:v:0 -map 1:a:0 "$video_file"
  #  mv "$backup_file" "$video_file"
}

# Audio.
extract-mp3() {
  input_file="$1"
  [ ! -f "$input_file" ] && echo "not a file: $input_file" && return 1
  mp3_file="$(strip_extension "$input_file").mp3"
  ffmpeg -v 5 -y -i "$input_file" -acodec libmp3lame -ac 2 -ab 220k "$mp3_file"
  #  ffmpeg -nostdin -v 5 -y -i "$input_file" -acodec libmp3lame -ac 2 -ab 220k "$mp3_file"
}

to-mp3() {
  unset input_file mp3_file
  input_file="$(realpath "$1")"
  [ ! -f "$input_file" ] && echo "not a file: $input_file" && return 1
  [[ "$input_file" == *.mp3 ]] && return

  mp3_file="$(strip_extension "$input_file").mp3"
  # -nostdin fixes a bug ffmpeg produces in loops involving reading from stdin.
  ffmpeg -nostdin -i "$input_file" -vn -c:a libmp3lame -q:a 2 "$mp3_file"
}

to-mp3-remove-input() {
  to-mp3 "$1" || return
  [ -f "$mp3_file" ] && rm "$input_file"
}

id3tags() { # uses ffprobe
  [ $# = 0 ] && echo "Usage: id3tags <AUDIO_FILE>" && return
  input_file="$1"
  tags_json="$(ffprobe -show_format -print_format json "$input_file")"
  tags_json="$(jq '.format.tags' <<<"$tags_json")"
  jq <<<"$tags_json"
}

embed-thumbnail-into-mp3() {
  [ $# = 0 ] && echo "Usage: embed-thumbnail-into-mp3 <THUMBNAIL_FILE> <AUDIO_FILE>" && return
  thumb_file="$1"
  input_file="$2"
  output_file="$(strip_extension "$input_file")_art.mp3"

  tags_json="$(id3tags "$input_file")"
  title="$(jq .title <<<"$tags_json" | tr -d '"')"
  artist="$(jq .artist <<<"$tags_json" | tr -d '"')"
  album="$(jq .album <<<"$tags_json" | tr -d '"')"
  year="$(jq .date <<<"$tags_json" | tr -d '"')"

  ffmpeg -i "$input_file" -i "$thumb_file" -map 0:0 -map 1:0 -c copy -id3v2_version 3 \
    -metadata title="$title" \
    -metadata artist="$artist" \
    -metadata album="$album" \
    -metadata year="$year" \
    -metadata:s:v title="Album cover" \
    -metadata:s:v comment="Cover (front)" \
    "$output_file"

  [ -f "$output_file" ] && mv "$output_file" "$input_file" && echo "thumbnail embedded into mp3" && return
  echo "embedding thumbnail failed"
}

strip-id3tags() { # not ffmpeg
  id3convert --strip "$1" 2>/dev/null # strip all id-tags as some choke the car radio
}

# pictures
screenshot_video_frame_changes() {
  [ -z "$1" ] && echo "usage: screenshots_changed_frames <VIDEO_FILE>" && return
  video_file="$1"
  frames_dir="$(dirname "$video_file")/screenshots"
  mkdir "$frames_dir"
  ffmpeg -i "$video_file" \
    -filter:v "select=bitor(gt(scene\,0.5)\,eq(n\,0)),blackframe=amount=1,metadata=mode=select:key=lavfi.blackframe.pblack:value=95:function=less" \
    -vsync drop "$frames_dir/%04d.jpg"
}
